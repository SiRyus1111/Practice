#include <iostream>
#include <bitset>
using namespace std;

// 비트 플래그 실습
int main(){

    // bool 변수 하나당 1바이트(8비트)인데, 어차피 true/false는 1비트로 표현 가능하지 않을까?
    // 그래서 그냥 1바이트 짜리 변수의 8개의 비트에 각각 플래그를 넣어보고, 수정해보고, 참조해봤다.
    // 비트 연산은 산술 연산/비교 연산보다 확실히 빠르므로, 이렇게 bool 형의 변수를 사용하지 않는 방식으로 최적화할 수 있다.
    // 게임 서버에서는 패킷을 보낼 때 1바이트라도 절약하는게 좋은데, 이렇게 하면 이론상으로는 8배 가까이 용량을 줄일 수 있다.
    // 만약 MTU(쉽게 말해서 패킷 전송 단위)가 1500바이트라고 하고, 유저 1000명의 8가지의 플래그를 패킷으로 보내야 한다면,
    // bool 형의 변수를 사용하면 1000 * 8로 8000바이트를 사용해야 해서 6번 패킷을 보내야 한다.
    // 하지만 비트 하나당 하나의 플래그를 저장해놓으면, MTU는 1500바이트 * 8 = 12000비트이고,
    // 우리는 8000 비트 == 1000바이트만 쓰면 되므로, 보내는 패킷의 크기를 상당히 줄일 수 있다. 패킷을 딱 1번만 보내면 된다!
    // 즉, 대역폭을 절약할 수 있다!
    // 어떻게 보면 경량화지. 경량화.

    unsigned char bit_plag = 0; // 비트 플래그
    bool plags[] = {true, false, true, true, false, true, false, false}; // 각각의 플래그를 배열로 저장, 물론 주석으로 플래그의 종류와 순서도 명시해야겠지..
    
    for (int i =0;i < 8; i++){
        if (i > 0) {
            bit_plag <<= 1; // 비트 시프트로 비트를 밀기
        } 
        // 비트 OR 연산은 둘 중 하나라도 1이면 1로 바꾸고, 
        // 일단 왼쪽 시프트하면 맨 오른쪽 비트는 0이므로 plags의 각 원소가 1이면 1이 추가되고, 0이면 0이 추가됨.
        bit_plag |= plags[i]; 
    }
    // 배열의 앞 순서(plags[0])를 왼쪽 시프트로 밀어 넣었기 때문에, 
    // bit_plag 내에서는 가장 높은 자리(7번 비트)에 위치하게 된다. 
    // 반대로 1 << n 연산은 오른쪽 끝(0번 비트)부터 계산하므로, 
    // 인덱싱을 할 때 이 방향 차이를 고려하는 것이 실전 비트 핸들링의 핵심이다.

    cout << bitset<8>(bit_plag) << endl; // 비트 플래그의 각각의 비트를 출력해봤다.

    // 특정 비트를 수정하기
    // 이렇게 특정 비트만 수정할 수도 있다.
    bit_plag &= ~(1 << 2); // 2번 비트(plags[5])를 1에서 0으로 수정
    bit_plag |= (1 << 2); // 2번 비트(plags[5])를 0에서 1로 수정
    
    // 그리고 비트 AND 연산자(&)를 이용해서 특정 비트의 값이 어떤지도 확인할 수 있다.
    // 그리고 이렇게 하면 (plags[1] == true)같은 일반적인 비교 연산보다 속도가 확실히 빠르다.
    // == 연산자나 & 연산자는 CPU에서 제로 플래그(ZF)를 참조해서 결정하게 된다.
    // 하지만 == 연산자는 두 값을 뺀(산술 연산) 후 그 결과가 0이면
    // ZF를 1로 설정하고, 아니면 0으로 설정해서, ZF의 값을 바탕으로 true/false를 결정한다.
    // 산술 연산이어서 비트 연산에 비해 느리다..
    // 하지만 비트 연산은 두 비트를 비트 AND 연산한 결과가 0이면 
    // ZF를 1로 설정하고, 아니면 0으로 설정해서, ZF의 값을 바탕으로 true/false를 결정한다.
    // 이건 == 연산자와 비슷해보이지만, 비트 연산이라서 상당히 빠르다.

    // 이러한 단순한 최적화도 서버 성능에 조금이지만 영향을 줄 수 있다.
    if (bit_plag & (1 << 6)){ // 6번 비트가 1인지 확인
        cout << "플래그 7은 true" << endl;
    }
    else {
        cout << "플래그 7은 false" << endl;
    }

    return 0;
}